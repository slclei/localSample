import {
  Component,
  OnInit,
  AfterViewInit,
  ViewChild,
  ElementRef,
  Renderer2,
} from '@angular/core';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import Stats from 'three/examples/jsm/libs/stats.module.js';
import wellsData from './wells';

@Component({
  selector: 'app-area-formation-dlg',
  templateUrl: './area-formation-dlg.component.html',
  styleUrls: ['./area-formation-dlg.component.css'],
})
export class AreaFormationDlgComponent implements AfterViewInit {
  container: any;
  stats: any;

  camera: any;
  scene: any;
  renderer: any;

  group: any;

  targetRotation = 0;
  targetRotationOnPointerDown = 0;

  pointerX = 0;
  pointerXOnPointerDown = 0;

  windowHalfX = window.innerWidth / 2;

  raycaster: any;
  INTERSECTED: any;
  pointer = new THREE.Vector2();
  radius = 5;
  theta = 0;

  controls: any;
  center: any;

  async ngAfterViewInit(): Promise<void> {
    this.init();
    this.animate();
  }

  private init() {
    this.container = document.getElementById('afd_container');

    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0xf0f0f0);

    this.camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      1,
      100
    );

    this.camera.position.set(0, 5, 5);
    this.scene.add(this.camera);

    const light = new THREE.PointLight(0xffffff, 2.5, 0, 0);
    this.camera.add(light);

    const loader = new THREE.TextureLoader();
    const texture = loader.load('assets/textures/uv_grid_opengl.jpg');
    texture.colorSpace = THREE.SRGBColorSpace;

    // it's necessary to apply these settings in order to correctly display the texture on a shape geometry

    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(0.008, 0.008);

    const addShape = (
      shape: THREE.Shape | THREE.Shape[] | undefined,
      extrudeSettings: THREE.ExtrudeGeometryOptions | undefined,
      color: number,
      x: number,
      y: number,
      z: number,
      rx: number,
      ry: number,
      rz: number,
      s: number
    ) => {
      // flat shape with texture
      // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

      let geometry: any;
      geometry = new THREE.ShapeGeometry(shape);

      let mesh = new THREE.Mesh(
        geometry,
        new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, map: texture })
      );
      mesh.position.set(x, y, z - 175);
      mesh.rotation.set(rx, ry, rz);
      mesh.scale.set(s, s, s);
      //this.group.add(mesh);

      // flat shape

      geometry = new THREE.ShapeGeometry(shape);

      mesh = new THREE.Mesh(
        geometry,
        new THREE.MeshPhongMaterial({ color: color, side: THREE.DoubleSide })
      );
      mesh.position.set(x, y, z - 125);
      mesh.rotation.set(rx, ry, rz);
      mesh.scale.set(s, s, s);

      var center = new THREE.Vector3();
      mesh.geometry.computeBoundingBox();
      mesh.geometry.boundingBox.getCenter(center);
      mesh.geometry.center();
      mesh.position.copy(center);
      this.center = center;
      this.scene.add(mesh);

      // extruded shape

      geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

      mesh = new THREE.Mesh(
        geometry,
        new THREE.MeshPhongMaterial({ color: color })
      );
      mesh.position.set(x, y, z - 75);
      mesh.rotation.set(rx, ry, rz);
      mesh.scale.set(s, s, s);      

      //this.scene.add(mesh);

      //addLineShape(shape, color, x, y, z, rx, ry, rz, s);
    };

    // Square
    const getMinimumSquare = (wells: any[]): number => {
      if (wells.length === 0) {
        return 0;
      }
    
      let minX = wells[0].Lat;
      let maxX = wells[0].Lat;
      let minY = wells[0].Long;
      let maxY = wells[0].Long;
    
      for (const well of wells) {
        minX = Math.min(minX, well.Lat);
        maxX = Math.max(maxX, well.Lat);
        minY = Math.min(minY, well.Long);
        maxY = Math.max(maxY, well.Long);
      }
    
      // Calculate the side length of the square
      const sideLength = Math.max(maxX - minX, maxY - minY);
    
      return sideLength;
    };

    const sqLength = getMinimumSquare(wellsData.wells);

    const squareShape = new THREE.Shape()
      .moveTo(0, 0)
      .lineTo(0, sqLength)
      .lineTo(sqLength, sqLength)
      .lineTo(sqLength, 0)
      .lineTo(0, 0);

    const extrudeSettings = {
      depth: 8,
      bevelEnabled: true,
      bevelSegments: 2,
      steps: 2,
      bevelSize: 1,
      bevelThickness: 1,
    };

    // addShape( shape, extrudeSettings, color, x, y, z, rx, ry,rz, s );

    addShape(squareShape, extrudeSettings, 0x0040f0, 150, 100, 0, 0, 0, 0, 1);
    //
    this.raycaster = new THREE.Raycaster();
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.useLegacyLights = false;
    this.container.appendChild(this.renderer.domElement);

    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.target.set(0, 0.5, 0);
    this.controls.update();
    this.controls.enablePan = false;
    this.controls.enableDamping = true;

    const axesHelper = new THREE.AxesHelper(5);
    axesHelper.position.copy(this.center);
    this.scene.add(axesHelper);

    this.stats = new Stats();
    this.container.appendChild(this.stats.dom);

    this.container.style.touchAction = 'none';
    this.container.addEventListener(
      'pointerdown',
      this.onPointerDown.bind(this)
    );

    this.container.addEventListener('click', this.onPointerClick.bind(this));

    //

    window.addEventListener('resize', this.onWindowResize.bind(this));
  }

  private onWindowResize() {
    this.windowHalfX = window.innerWidth / 2;

    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();

    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }

  //

  private onPointerDown(event: any) {
    if (event.isPrimary === false) return;

    this.pointerXOnPointerDown = event.clientX - this.windowHalfX;
    this.targetRotationOnPointerDown = this.targetRotation;

    document.addEventListener('pointermove', this.onPointerMove);
    document.addEventListener('pointerup', this.onPointerUp);
  }

  private onPointerMove = (event: any) => {
    if (event.isPrimary === false) return;

    this.pointerX = event.clientX - this.windowHalfX;

    this.targetRotation =
      this.targetRotationOnPointerDown +
      (this.pointerX - this.pointerXOnPointerDown) * 0.02;
  };

  private onPointerUp = (event: any) => {
    if (event.isPrimary === false) return;

    document.removeEventListener('pointermove', this.onPointerMove);
    document.removeEventListener('pointerup', this.onPointerUp);
  };

  private onPointerClick(event: MouseEvent) {
    let B = this.renderer.domElement.getBoundingClientRect();

    this.pointer.x = ((event.clientX - B.left) / (B.right - B.left)) * 2 - 1;
    this.pointer.y = -((event.clientY - B.top) / (B.bottom - B.top)) * 2 + 1;
  }

  //

  private animate() {
    requestAnimationFrame(() => this.animate());

    this.controls.update();

    this.render();
    this.stats.update();
  }

  private render() {
    this.camera.lookAt(this.center);

    this.camera.updateMatrixWorld();

    // find intersections

    this.raycaster.setFromCamera(this.pointer, this.camera);

    const intersects = this.raycaster.intersectObjects(
      this.scene.children,
      false
    );

    if (intersects.length > 0) {
      if (this.INTERSECTED != intersects[0].object) {
        if (this.INTERSECTED && this.INTERSECTED.material && this.INTERSECTED.material.emissive)
          this.INTERSECTED.material.emissive.setHex(
            this.INTERSECTED.currentHex
          );

        this.INTERSECTED = intersects[0].object;

        if (this.INTERSECTED && this.INTERSECTED.material && this.INTERSECTED.material.emissive)
        {this.INTERSECTED.currentHex =
          this.INTERSECTED.material.emissive.getHex();
        this.INTERSECTED.material.emissive.setHex(0xff0000);}
      }
    } else {
      if (this.INTERSECTED && this.INTERSECTED.material && this.INTERSECTED.material.emissive)
        this.INTERSECTED.material.emissive.setHex(this.INTERSECTED.currentHex);

      this.INTERSECTED = null;
    }

    this.renderer.render(this.scene, this.camera);
  }
}
